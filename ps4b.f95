PROGRAM PS4B
    IMPLICIT NONE
    ! FOR PARAMETERS
    REAL:: ALPHA=1.5, BETA=0.8, INTEREST=0.04, RHO=0.9
    REAL, DIMENSION(2):: STATES = (/1.0, 0.5/)
    REAL, DIMENSION(2,2):: EMP_MARKOV = TRANSPOSE(RESHAPE((/0.75,0.25,0.25,0.75/),(/2,2/)))
    INTEGER:: NZ=SIZE(STATES)
    REAL(KIND=8):: A_MAX=2.0, A_MIN=-0.525, STEP=0.005
    INTEGER:: NA
    REAL, DIMENSION(:), ALLOCATABLE:: A_GRID
    INTEGER:: ZERO_LOC
    ! FOR LOOPING
    REAL(KIND=8):: ERROR_VFI, ERROR_CLEAN, ERROR_DEF, ERROR_Q=100., ERROR_STAT ! INITIAL ERRORS TO BE UPDATED
    REAL(KIND=8):: CRIT_VFI=1e-3, CRIT_Q=1e-3, CRIT_STAT=1e-3 ! CRITICAL TOLERANCE VALUES
    INTEGER:: SROWIDX, SCOLIDX, CHOICEIDX, TROWIDX, TCOLIDX, I ! SOME INDEXES FOR VARIOUS LOOPS
    BOOL:: POOL=0 ! BOOLEAN FOR POOLING OR SEPARTING EQUILIBRIUM
    INTEGER:: INTDEBUGGER
    REAL:: FLOATDEBUGGER ! A PAIR OF DEBUGGERS
    ! FOR RESULTS
    REAL(KIND=8), DIMENSION(:,:), ALLOCATABLE:: VFUNC_CLEAN, VFUNC_CLEAN_NEW, VFUNC_DEF, VFUNC_DEF_NEW
    INTEGER, DIMENSION(:,:), ALLOCATABLE:: PFUNC, DFUNC
    REAL(KIND=8), DIMENSION(:), ALLOCATABLE:: STAT_DIST, STAT_DIST_NEW
    REAL(KIND=8), DIMENSION(:,:), ALLOCATABLE:: A_TRANSITION_MAT
    REAL(KIND=8), DIMENSION(:,:), ALLOCATABLE:: Q ! LIST OF BOND PRICE GIVEN RISK OF DEFAULTING

    ! INIT VARIABLES
    NA = (A_MAX-A_MIN)/STEP + 1
    ZERO_LOC = ABS(A_MIN)/0.005 +1
    ! INIT ARRAYS
    A_GRID = (/(I*STEP, I=1,NA)/) + A_MIN - STEP
    PRINT*, A_GRID(ZERO_LOC)
    ! MAIN LOOP
    DO WHILE (ERROR_Q>CRIT_Q)
        ! VFI (GIVE A BOOL TO INDICATE POOLING/SEPARATING)
        ERROR_VFI = 100
        DO WHILE (ERROR_VFI>CRIT_VFI)  ! START VFI
            CALL BELLMAN_CLEAN() !START BELLMAN CLEAN
            CALL BELLMAN_DEFAULT() ! START BELLMAN DEFAULTED
        ENDDO ! END VFI
        CALL CREATE_A_TRASITION_MAT() ! CREATE MARKOV TRASITION MATRIX FOR
        CALL FIND_STAT_DIST() ! STATIONARY DISTRIBUTION
        ! COMPUTE ERROR AND Q DIFFERENTLY FOR DIFFERENT EQUILIBRIUM
        IF (POOL==0) THEN
            CALL Q_POOLING()
        ELSE
            CALL Q_SEPARATING()
        ENDIF
        ! CHECK MARKET CLEARING CONDITIONS
        ! UPDATE Q IF ERROR IS STILL BIG
        ERROR_Q = 1e-4
    ENDDO

    CALL WRITE_ALL()! WRITE RESULTS FOR PLOTTING USE


END PROGRAM PS4B

! RULE: ONLY ONE OUTER LOOP PER SUBROUTINE
SUBROUTINE BELLMAN_CLEAN(A_GRID, Q, STATES)
    IMPLICIT NONE
    REAL:: COND_MAX_UTIL
    REAL, INTENT(IN):: ALPHA, BETA
    REAL, DIMENSION(:,:), INTENT(IN):: Q, A_GRID, STATES
    REAL, DIMENSION(:,:), ALLOCATABLE:: VF_NEXT
    REAL, DIMENSION(:,:), ALLOCATABLE, INTENT(OUT):: VFUNC_CLEAN
    REAL, INTENT(OUT):: ERROR

    DO SCOLIDX = 1, NZ!START BELLMAN CLEAN
        DO SROWIDX=1, NA
            COND_MAX_UTIL = -1e12
            DO CHOICEIDX=1,NA ! LOOP OVER CHOICE OF ASSET PRIME
                CONSUM = A_GRID(SROWIDX) + STATES(SCOLIDX) - Q(CHOICEIDX, SCOLIDX)* A_GRID(CHOICEIDX)
                IF (CONSUM > 0.) THEN
                    UTIL = ((CONSUM**(1-ALPHA)-1)/(1-ALPHA))+BETA*SUM(TRASITION(SCOLIDX,:)*VFUNC(CHOICEIDX,:))
                ENDIF
            ENDDO
        ENDDO
    ENDDO ! END BELLMAN CLEAN
END SUBROUTINE

SUBROUTINE BELLMAN_DEFAULT()

END SUBROUTINE

SUBROUTINE CREATE_A_TRASITION_MAT()
    INTEGER:: SROWIDX, SCOLIDX, CHOICEIDX, TROWIDX, TCOLIDX
    REAL(KIND=8),INTENT(OUT):: A_TRANSITION_MAT

    ! THE ASSET TRASITION MATRIX IS ARRANGED AS (CLEAN_EMPLOYED(A1-AN), CLEAN_UNEMP(A1-N), DEF_EMP(1-N), DEF_UNEMP(1-N))
    A_TRANSITION_MAT(:,:) = 0.
    DO SROWIDX=1, NA
        DO SCOLIDX=1, NZ
            DO H=0, 1
                TROWIDX = SROWIDX +(SCOLIDX-1)*NA + H*(NA*NZ)
                ! FEELING LIKE I SHOULD MERGE THE POLICY FUNC INTO 1
                IF (H==0) THEN
                    APIDX = PFUNC_CLEAN(SROWIDX, SCOLIDX)
                ELSE
                    APIDX = PFUNC_DEF(SROWIDX, SCOLIDX)
                ENDIF
                DO CHOICEIDX=1, NA
                    
                ENDDO
            ENDDO
        ENDDO
    ENDDO


END SUBROUTINE

SUBROUTINE FIND_STAT_DIST()

END SUBROUTINE

SUBROUTINE Q_SEPARATING(ERROR_Q, CRIT_Q)

END SUBROUTINE

SUBROUTINE Q_POOLING(ERROR_Q, CRIT_Q)


END SUBROUTINE


SUBROUTINE WRITE_ALL(RES)
    INTENT(IN):: RES
    ! STRING:: NAMES
    INTEGER:: IDX

    ! DO  FOR IDX, NAME, ARRAYS IN ENUMERATE(LIST OF RESULTS)
       ! OPEN(UNIT=IDX, FILE="/Users/chek_choi/Downloads/fortran/NAME", STATUS="REPLACE")
       ! WRITE(UNIT=IDX, FMT=*) ARRAYS
       ! CLOSE(UNIT=IDX)
    ! ENDDO
END SUBROUTINE

