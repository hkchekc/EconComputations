PROGRAM PS4B ! MAIN PROGRAM
    IMPLICIT NONE
    ! FOR PARAMETERS
    REAL:: ALPHA=1.5, BETA=0.8, INTEREST=0.04, RHO=0.9
    REAL, DIMENSION(2):: STATES = (/1.0, 0.5/)
    REAL, DIMENSION(2,2):: EMP_MARKOV = TRANSPOSE(RESHAPE((/0.75,0.25,0.25,0.75/),(/2,2/)))
    INTEGER:: NZ=SIZE(STATES)
    REAL(KIND=8):: A_MAX=2.0, A_MIN=-0.525, STEP=0.005
    INTEGER:: NA
    REAL, DIMENSION(:), ALLOCATABLE:: A_GRID
    INTEGER:: ZERO_LOC
    ! FOR LOOPING
    REAL(KIND=8):: ERROR_VFI, ERROR_CLEAN, ERROR_DEF, ERROR_Q=100. ! INITIAL ERRORS TO BE UPDATED
    REAL(KIND=8):: CRIT_VFI=1e-3, CRIT_Q=1e-3 ! CRITICAL TOLERANCE VALUES
    INTEGER:: SROWIDX, SCOLIDX, CHOICEIDX, TROWIDX, TCOLIDX, I ! SOME INDEXES FOR VARIOUS LOOPS
    LOGICAL:: POOL= .FALSE. ! BOOLEAN FOR POOLING OR SEPARTING EQUILIBRIUM
    INTEGER:: INTDEBUGGER
    REAL:: FLOATDEBUGGER ! A PAIR OF DEBUGGERS
    ! FOR RESULTS
    REAL(KIND=8), DIMENSION(:,:), ALLOCATABLE:: VFUNC_CLEAN, VFUNC_CLEAN_NEW, VFUNC_DEF, VFUNC_DEF_NEW
    INTEGER, DIMENSION(:,:), ALLOCATABLE:: PFUNC_CLEAN, PFUNC_DEF, DFUNC
    REAL(KIND=8), DIMENSION(:), ALLOCATABLE:: STAT_DIST, STAT_DIST_NEW
    REAL(KIND=8), DIMENSION(:,:), ALLOCATABLE:: A_TRANSITION_MAT
    REAL(KIND=8), DIMENSION(:,:), ALLOCATABLE:: Q ! LIST OF BOND PRICE GIVEN RISK OF DEFAULTING

    ! INIT VARIABLES
    NA = (A_MAX-A_MIN)/STEP + 1
    ZERO_LOC = ABS(A_MIN)/0.005 +1
    ! INIT ARRAYS
    ALLOCATE(A_GRID(NA))
    A_GRID = (/(I*STEP, I=1,NA)/) + A_MIN - STEP
    PRINT*, A_GRID(ZERO_LOC)
    ALLOCATE(VFUNC_CLEAN(NA,NZ))
    VFUNC_CLEAN(:,:) = 0.
    VFUNC_DEF = VFUNC_CLEAN
    VFUNC_CLEAN_NEW = VFUNC_CLEAN
    VFUNC_DEF_NEW = VFUNC_CLEAN
    ALLOCATE(STAT_DIST(NA*NZ))
    STAT_DIST(:) = 1/(NA*NA*2)
    STAT_DIST_NEW = STAT_DIST
    ALLOCATE(A_CHANGE_MAT(NA*NZ*2,NA*NZ*2))
    A_CHANGE_MAT(:,:) = 0.
    ! INIT POLICY FUNCTION
    ALLOCATE(PFUNC_CLEAN(NA,NZ))
    PFUNC_CLEAN(:,:)=0
    PFUNC_DEF= PFUNC_CLEAN
    ALLOCATE(DFUNC(NA,NZ))
    DFUNC = 0

    ! MAIN LOOP
    DO WHILE (ERROR_Q>CRIT_Q)
        ! VFI (GIVE A BOOL TO INDICATE POOLING/SEPARATING)
        ERROR_VFI = 100
        DO WHILE (ERROR_VFI>CRIT_VFI)  ! START VFI
            CALL BELLMAN_CLEAN(ALPHA, BETA, NA, NZ, ZERO_LOC, Q, A_GRID, STATES, VFUNC_CLEAN, PFUNC_CLEAN, ERROR_CLEAN) !START BELLMAN CLEAN
            CALL BELLMAN_DEFAULT(ALPHA, BETA, NA, NZ, ZERO_LOC, Q, VFUNC_CLEAN, A_GRID, STATES, VFUNC_DEF, PFUNC_DEF, ERROR_DEF) ! START BELLMAN DEFAULTED
            ERROR_VFI = MAX(ERROR_CLEAN, ERROR_DEF)
        ENDDO ! END VFI
        ! COMPARE IS CLEAN OR DEFAULT IS BETTER AND SET DFUNC
        DFUNC(:,:) = VFUNC_DEF > VFUNC_CLEAN
        CALL CREATE_A_TRANSITION_MAT(PFUNC_CLEAN, PFUNC_DEF, DFUNC, EMP_MARKOV, NA, NZ, RHO, A_TRANSITION_MAT) ! CREATE MARKOV TRANSITION MATRIX FOR
        CALL FIND_STAT_DIST(STAT_DIST) ! STATIONARY DISTRIBUTION
        ! COMPUTE ERROR AND Q DIFFERENTLY FOR DIFFERENT EQUILIBRIUM
        IF (POOL) THEN
            CALL Q_POOLING()
        ELSE
            CALL Q_SEPARATING()
        ENDIF
        ! CHECK MARKET CLEARING CONDITIONS
        ! UPDATE Q IF ERROR IS STILL BIG
        ERROR_Q = 1e-4
    ENDDO

    CALL WRITE_ALL()! WRITE RESULTS FOR PLOTTING USE

END PROGRAM PS4B

! ALL SUBROUTINES
! RULE: ONLY ONE OUTER LOOP PER SUBROUTINE
SUBROUTINE BELLMAN_CLEAN(ALPHA, BETA, NA, NZ, ZERO_LOC, Q, A_GRID, STATES, VFUNC_CLEAN, PFUNC_CLEAN, ERROR_CLEAN)
    IMPLICIT NONE
    REAL, INTENT(IN):: ALPHA, BETA
    INTEGER, INTENT(IN):: NA, NZ
    REAL, DIMENSION(:,:), INTENT(IN):: A_GRID, STATES
    REAL, DIMENSION(:,:), INTENT(IN):: Q
    REAL, DIMENSION(:,:), ALLOCATABLE, INTENT(INOUT):: VFUNC_CLEAN, PFUNC_CLEAN
    REAL, INTENT(OUT):: ERROR_CLEAN
    REAL, DIMENSION(:,:), ALLOCATABLE:: VFUNC_CLEAN_NEW
    REAL:: COND_MAX_UTIL, CONSUM, UTIL
    INTEGER:: SROWIDX, SCOLIDX, CHOICEIDX

    DO SCOLIDX = 1, NZ!START BELLMAN CLEAN
        DO SROWIDX=1, NA
            COND_MAX_UTIL = -1e12
            DO CHOICEIDX=1,NA ! LOOP OVER CHOICE OF ASSET PRIME
                CONSUM = A_GRID(SROWIDX) + STATES(SCOLIDX) - Q(CHOICEIDX, SCOLIDX)* A_GRID(CHOICEIDX)
                IF (CONSUM > 0.) THEN
                    UTIL = ((CONSUM**(1-ALPHA)-1)/(1-ALPHA))+BETA*SUM(EMP_MARKOV(SCOLIDX,:)*VFUNC(CHOICEIDX,:))
                    IF (UTIL>COND_MAX_UTIL) THEN
                        PFUNC_CLEAN(SROWIDX, SCOLIDX) = CHOICEIDX
                        COND_MAX_UTIL = UTIL
                    ENDIF
                ENDIF
            ENDDO ! END LOOP CHOICE SPACE FOR ONE STATE
            VFUNC_CLEAN_NEW(SROWIDX, SCOLIDX) = COND_MAX_UTIL
        ENDDO
    ENDDO ! END BELLMAN CLEAN
    ERROR_CLEAN = MAXVAL(ABS(VFUNC_CLEAN_NEW - VFUNC_CLEAN))
    VFUNC_CLEAN = VFUNC_CLEAN_NEW
END SUBROUTINE

SUBROUTINE BELLMAN_DEFAULT(ALPHA, BETA, NA, NZ, ZERO_LOC, Q, VFUNC_CLEAN, A_GRID, STATES, VFUNC_DEF, PFUNC_DEF, ERROR_DEF)
    IMPLICIT NONE
    REAL, INTENT(IN):: ALPHA, BETA, RHO
    INTEGER, INTENT(IN):: NA, NZ, ZERO_LOC
    REAL, DIMENSION(:), INTENT(IN):: A_GRID, STATES
    REAL, DIMENSION(:,:), INTENT(IN):: Q, VFUNC_CLEAN
    REAL, DIMENSION(:,:), ALLOCATABLE, INTENT(INOUT):: VFUNC_DEF, PFUNC_DEF
    REAL, INTENT(OUT):: ERROR_DEF
    REAL, DIMENSION(:,:), ALLOCATABLE:: VFUNC_DEF_NEW
    REAL:: COND_MAX_UTIL, CONSUM, UTIL
    INTEGER:: SROWIDX, SCOLIDX, CHOICEIDX

    DO SCOLIDX=1, NZ
        DO SROWIDX= ZERO_LOC, NA ! NOT POSSIBLE TO HAVE BORROWED MONEY FOR DEFAULTED PEOPL
            COND_MAX_UTIL = -1e12
            DO CHOICEIDX= ZERO_LOC, NA ! LOOP OVER CHOICE; AGAIN, NOT POSSIBLE TO HAVE BORROWED MONEY
                CONSUM = A_GRID(SROWIDX) + STATES(SCOLIDX) - Q(CHOICEIDX, SCOLIDX)* A_GRID(CHOICEIDX)
                IF (CONSUM > 0.) THEN
                    UTIL = ((CONSUM**(1-ALPHA)-1)/(1-ALPHA))+BETA*(RHO*SUM(EMP_MARKOV(SCOLIDX,:)*VFUNC_DEF(CHOICEIDX,:))+(1-RHO)*SUM(EMP_MARKOV(SCOLIDX,:)*VFUNC_CLEAN(CHOICEIDX,:)))
                    IF (UTIL>COND_MAX_UTIL) THEN
                        PFUNC_DEF(SROWIDX, SCOLIDX) = CHOICEIDX
                        COND_MAX_UTIL = UTIL
                    ENDIF
                ENDIF
            ENDDO ! END LOOPING CHOICE
            VFUNC_DEF(SROWIDX, SCOLIDX) = COND_MAX_UTIL
        ENDDO
    ENDDO
    ERROR_DEF = MAXVAL(ABS(VFUNC_DEF_NEW - VFUNC_DEF))
    VFUNC_DEF = VFUNC_DEF_NEW
END SUBROUTINE

SUBROUTINE CREATE_A_TRANSITION_MAT(PFUNC_CLEAN, PFUNC_DEF, DFUNC, EMP_MARKOV, NA, NZ, RHO, A_TRANSITION_MAT)
    IMPLICIT NONE
    INTEGER, DIMENSION(:,:), INTENT(IN):: PFUNC_CLEAN, PFUNC_DEF, DFUNC, EMP_MARKOV
    INTEGER, INTENT(IN):: NA, NZ
    REAL, INTENT(IN):: RHO
    REAL(KIND=8),INTENT(OUT):: A_TRANSITION_MAT
    INTEGER:: SROWIDX, SCOLIDX, TROWIDX, TCOLIDX, H, AP_CHOICE, EMPIDX, NO_FLAG_COL, STAY_FLAG_COL


    ! THE ASSET TRANSITION MATRIX IS ARRANGED AS (CLEAN_EMPLOYED(A1-AN), CLEAN_UNEMP(A1-N), DEF_EMP(1-N), DEF_UNEMP(1-N))
    A_TRANSITION_MAT(:,:) = 0.
    ! POPULATE MARKOV ASSET MARTRIX
    DO SROWIDX=1, NA
        DO SCOLIDX=1, NZ
            DO H=0, 1
                TROWIDX = SROWIDX +(SCOLIDX-1)*NA + H*(NA*NZ)
                ! FEELING LIKE I SHOULD MERGE THE POLICY FUNC INTO 1
                IF (H==0) THEN
                    AP_CHOICE = PFUNC_CLEAN(SROWIDX, SCOLIDX)
                ELSE
                    AP_CHOICE = PFUNC_DEF(SROWIDX, SCOLIDX)
                ENDIF
                IF (H==0) THEN ! IF NOT YET DEFAULTED
                    IF (DFUNC(SROWIDX, SCOLIDX)==1) THEN ! IF CHOOSE TO DEFAULT
                        DO EMPIDX=1,NZ
                            TCOLIDX = NA+NA*EMPIDX+1
                            A_TRANSITION_MAT(TROWIDX, TCOLIDX) = EMP_MARKOV(SCOLIDX, EMPIDX)
                        ENDDO
                    ELSE ! IF CHOOSE NOT TO DEFAULT
                        DO EMPIDX=1, NZ
                            TCOLIDX = NA*(EMPIDX-1) + AP_CHOICE
                            A_TRANSITION_MAT(TROWIDX, TCOLIDX) = EMP_MARKOV(SCOLIDX, EMPIDX)
                        ENDDO
                    ENDIF
                ELSE ! IF ALREADY DEFAULTED
                    DO EMPIDX=1, NZ
                        NO_FLAG_COL = NA*(EMPIDX-1) + AP_CHOICE ! WHEN DEFAULT FLAG IS REMOVED - CLEAN AGAIN
                        STAY_FLAG_COL = 2*NA + NA*(EMPIDX-1) + AP_CHOICE ! WHEN DEFAULT FLAG STAYS
                        A_TRANSITION_MAT(SROWIDX, NO_FLAG_COL) = (1-RHO)*EMP_MARKOV(SCOLIDX, EMPIDX)
                        A_TRANSITION_MAT(SROWIDX, STAY_FLAG_COL) = RHO*EMP_MARKOV(SCOLIDX, EMPIDX)
                    ENDDO
                ENDIF
            ENDDO ! END H LOOP
        ENDDO ! END NZ-SCOL LOOP
    ENDDO ! END NA-SROW LOOP

END SUBROUTINE

SUBROUTINE FIND_STAT_DIST(STAT_DIST)
    IMPLICIT NONE
    REAL(KIND=8), INTENT(INOUT):: STAT_DIST
    REAL(KIND=8), DIMENSION(:), ALLOCATABLE :: STAT_DIST_NEW
    REAL(KIND=8):: ERROR_STAT=100, CRIT_STAT=1e-3

    STAT_DIST_NEW = STAT_DIST
    STAT_DIST_NEW(:) = 0.
    DO WHILE (ERROR_STAT>CRIT_STAT)
        STAT_DIST = MATMUL(STAT_DIST, A_TRANSITION_MAT)
        ERROR_STAT = MAXVAL(ABS(STAT_DIST_NEW - STAT_DIST))
        STAT_DIST = STAT_DIST_NEW
    ENDDO
END SUBROUTINE

SUBROUTINE Q_SEPARATING(ZERO_LOC, NA, NZ, DFUNC, EMP_MARKOV, Q, ERROR_Q)
    IMPLICIT NONE
    INTEGER, INTENT(IN):: ZERO_LOC, NA, NZ
    INTEGER, DIMENSION(:,:), INTENT(IN):: DFUNC, EMP_MARKOV
    REAL(KIND=8), DIMENSION(:), INTENT(IN):: A_GRID
    REAL(KIND=8), INTENT(INOUT):: Q
    REAL(KIND=8), INTENT(INOUT):: ERROR_Q = 100.
    REAL(KIND=8):: CRIT_Q = 1e-3, RISK
    INTEGER:: SROWIDX, SCOLIDX, NEXT_STATE_IDX

    ! FIRST CALCUALTE ERROR
    DO SROWIDX=1,NA
        DO SCOLIDX=1, NZ
            RISK = 0.0
            DO NEXT_STATE_IDX=1, NZ
                RISK = RISK + EMP_MARKOV(SCOLIDX, NEXT_STATE_IDX)*DFUNC(SROWIDX, NEXT_STATE_IDX)
            ENDDO
        ENDDO
        ERROR_Q =
    ENDDO

    IF (ERROR_Q> CRIT_Q) THEN

    ENDIF

END SUBROUTINE

SUBROUTINE Q_POOLING(ZERO_LOC, NA, NZ, DFUNC)
    ! SHIFT Q WITH SAME AMOUNT
    IMPLICIT NONE
    INTEGER, INTENT(IN):: ZERO_LOC, NA, NZ
    INTEGER, DIMENSION(:,:), INTENT(IN):: DFUNC
    REAL(KIND=8), DIMENSION(:), INTENT(IN):: STAT_DIST, A_GRID
    REAL(KIND=8), INTENT(OUT):: Q, ERROR_Q = 100.
    REAL(KIND=8):: CRIT_Q = 1e-3, TOTAL_LOSS=0., TOTAL_BORROW=0., LOSS_RATE=0.
    INTEGER:: SROWIDX, SCOLIDX, AP_CHOICE

    DO SCOLIDX=1, NZ
        DO SROWIDX= 1, NA
            IF (SROWIDX=ZERO_LOC, NA) THEN ! WAIT, BUT WHERE IS THE DEFAULTED PEOPLE, THEY STILL SAVE
                AP_CHOICE = PFUNC_CLEAN(SROWIDX, SCOLIDX)
                IF A_GRID(AP_CHOICE) > 0
                    TOTAL_BORROW = TOTAL_BORROW + A_GRID(AP_CHOICE)*STAT_DIST(SROWIDX, SCOLIDX)
                ENDIF
            ELSE
                IF (DFUNC(SROWIDX, SCOLIDX)==1) THEN
                    TOTAL_LOSS =  TOTAL_LOSS- A_GRID(SROWIDX, SCOLIDX)*STAT_DIST(SROWIDX, SCOLIDX)
                ENDIF
            ENDIF
        ENDDO
    ENDDO
    ! UPDATE LOSS RATE
    LOSS_RATE= TOTAL_LOSS/TOTAL_BORROW
    ERROR_Q = ABS(LOSS_RATE-INTEREST) ! NO NEED TO UPDATE INTEREST
    ! UPDATE Q
    IF (ERROR_Q>CRIT_Q)
        DO SCOLIDX=1,NZ
            DO SROWIDX=1, ZERO_LOC
                Q(SROWIDX, SCOLIDX) = Q(SROWIDX, SCOLIDX) - 1/LOSS_RATE
            ENDDO
        ENDDO
    ENDIF
END SUBROUTINE


