MODULE PS6PARA
    IMPLICIT NONE
    INTEGER:: I
    INTEGER, PARAMETER:: N=66, RETIRE_AGE=46, T=30, CHANGE=2 ! LIFE EXPECTANCY, RETIREMENT, PERIODS
    REAL(KIND=8), PARAMETER:: A_MAX=20.1, A_MIN=0.1, STEP=1.0
    INTEGER, PARAMETER:: NZ=2, NA=(A_MAX-A_MIN)/STEP+1
    REAL(KIND=8):: ALPHA=0.36, BETA=0.97
    REAL(KIND=8), PARAMETER:: GAMMA=0.42, SIGMA=2.0, DELTA=0.06, POP_GROWTH= 0.011
    REAL(KIND=8), DIMENSION(2):: PROD_STATES = (/3.0, 0.5/)
    REAL(KIND=8), DIMENSION(2,2):: PROD_MARKOV = TRANSPOSE(RESHAPE((/0.9261,(1-0.9261),(1-0.9811),0.9811/),(/NZ,NZ/)))
    REAL(KIND=8), DIMENSION(NA):: A_GRID = (/(I*STEP, I=1,NA)/) + A_MIN - STEP
    REAL(KIND=8), DIMENSION(N):: COHORT_POP
    REAL(KIND=8), DIMENSION(N,NZ):: AGE_EFF=0.
    REAL(KIND=8), DIMENSION(45):: EF
    REAL(KIND=8)::THETA, THE_OLD=0.11, THE_NEW=0.0
    CONTAINS
        SUBROUTINE INIT_ARRAY()
            COHORT_POP = (/((1.0/((1.0+POP_GROWTH)**I)), I=1,N)/)
            COHORT_POP = COHORT_POP/SUM(COHORT_POP)
            OPEN(UNIT=13, FILE='ef.txt', STATUS='OLD')
            DO I=1,RETIRE_AGE-1
                READ(UNIT=13, FMT=*) EF(I)
            ENDDO
            CLOSE(UNIT=13)
            DO I=1,RETIRE_AGE-1
            AGE_EFF(I,1) = EF(I)*PROD_STATES(1)
            AGE_EFF(I,2) = EF(I)*PROD_STATES(2)
            ENDDO
        END SUBROUTINE
END MODULE

MODULE PS6RES
    USE PS6PARA
    IMPLICIT NONE
    REAL(KIND=8):: ERROR_MAIN=100., ERROR_EP
    REAL(KIND=8), DIMENSION(T):: WAGE, AGG_LABOR=1.0, AGG_CAP=2.0, BEN, INTEREST
    REAL(KIND=8), DIMENSION(T):: ACAP_NEW, ALAB_NEW
    REAL(KIND=8), DIMENSION(NA,NZ,N,T):: VFUNC, LFUNC, STAT_DIST, VFUNC_OLD
    INTEGER, DIMENSION(NA,NZ,N,T):: PFUNC=1
END MODULE

PROGRAM PS6
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    REAL(KIND=8):: CRIT_MAIN=1e-2, DEL_LAB, DEL_CAP
    INTEGER:: IDX, PERIOD, DEBUG=0.

    CALL INIT_ARRAY()
    CALL COMPUTE_EP() ! CALCULATE STEADY STATE EQ UNDER NEW THETA
    DO IDX=2,T-1 ! INITIAL GUESS
        DEL_CAP = AGG_CAP(T)-AGG_CAP(1)
        DEL_LAB = AGG_LABOR(T)-AGG_LABOR(1)
        AGG_LABOR(IDX) =AGG_LABOR(1) + DEL_LAB*(FLOAT(IDX)-1.)/FLOAT(T)
        AGG_CAP(IDX) = AGG_CAP(1)+DEL_CAP*(FLOAT(IDX)-1.)/FLOAT(T)
    ENDDO
       ! START MAIN LOOP
    DO WHILE (ERROR_MAIN>CRIT_MAIN)
        DO IDX=2, T-1
            CALL CAL_POINT_MOM(IDX)
        ENDDO
        VFUNC(:,:,:,2:T-1)=0.
        LFUNC(:,:,:,2:T-1) =0.
        PFUNC(:,:,:,2:T-1)=1

        !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(THETA,IDX, PERIOD)
        DO IDX=1, T-1
            IF (IDX<CHANGE) THEN
                THETA = THE_OLD
            ELSE
                THETA = THE_NEW
            ENDIF
            PERIOD = T-IDX
            CALL BACKWARD_INDUCTION(PERIOD)

        ENDDO
        !$OMP END PARALLEL DO
        CALL FIND_STAT_DIST()
        ! COMPUTE ERROR UPDATE PRICE
        CALL COMPUTE_ERROR()
        ! END CONDITIONS FOR DEBUG
        DEBUG = DEBUG+1
        IF (DEBUG>1000) THEN
            ERROR_MAIN=0.00000001
            PRINT*, "OK, I AM SCREWEDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD"
        ENDIF
        PRINT*, "STATDIST, SUM, NONZERO", SUM(STAT_DIST), COUNT(STAT_DIST/=0)
        PRINT*, "ERROR: MAIN, ENDPOINT", ERROR_MAIN, ERROR_EP
        PRINT*, "R, B,W:", INTEREST(T-1), SUM(BEN(2:T))/FLOAT(T-1), SUM(WAGE)/FLOAT(T)
        PRINT*, "VFUNC: NONZERO, SIZE", COUNT(VFUNC/=0), SIZE(VFUNC)
        PRINT*, "======================================="
    ENDDO
    DO IDX=1, T
        CALL CAL_POINT_MOM(IDX)
    ENDDO

    CALL WRITE_ALL()
    CALL CONSUM_EQ()
END PROGRAM PS6

SUBROUTINE COMPUTE_EP()
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    REAL(KIND=8):: CRIT_EP=1e-3
    INTEGER, DIMENSION(2):: EPS=(/1,T/)
    INTEGER:: TIDX, IDX

    DO IDX=1,2
        TIDX=EPS(IDX)
        PRINT*, NA
        ERROR_EP=100.
        DO WHILE(ERROR_EP>CRIT_EP)
            CALL CAL_POINT_MOM(TIDX)
            PRINT*, "=================================================="
            PRINT*, "R, B,W:", INTEREST(TIDX), BEN(TIDX), WAGE(TIDX)
            PRINT*,  "L, K:",AGG_LABOR(TIDX), AGG_CAP(TIDX)
            ! BACKWARD INDUCTION USING NEW VARS (BELLMAN)
            CALL BACKWARD_INDUCTION(TIDX)
            ! UPDATE STAT_DIST
            CALL EP_STAT_DIST(TIDX)
            ! OBSERVE ERROR AND UPDATE PRICE
            CALL EP_PRICE(TIDX, .TRUE.)
        ENDDO

        CALL CAL_POINT_MOM(TIDX)
    ENDDO

END SUBROUTINE

SUBROUTINE FIND_STAT_DIST()
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    INTEGER:: SROWIDX, SCOLIDX, AGEIDX, LAST_AGE, LAST_CHOICE, TIDX,IDX
    REAL(KIND=8), DIMENSION(NA,NZ,N,T):: STAT_DIST_NEW
    REAL(KIND=8):: OLD_POP

    STAT_DIST_NEW(:,:,:,1) = STAT_DIST(:,:,:,1)
    STAT_DIST_NEW(:,:,:,T) = STAT_DIST(:,:,:,T)
    DO TIDX=2,T-1 ! INITIAL EXCEPT ENDPOINTS
        ! EVERYONE HAVE ZERO ASSET AT STARTING AGE
        STAT_DIST_NEW(:,:,:,TIDX) = 0.
        STAT_DIST_NEW(1,1,1,TIDX) = 0.2037*COHORT_POP(1) ! ALWAYS NO ASSET AT FIRST AGE, BUT 2 PROD STATES
        STAT_DIST_NEW(1,2,1,TIDX) = 0.7963*COHORT_POP(1)
    ENDDO
    DO TIDX=2,T-1 ! OMIT END POINTS
        DO AGEIDX=2, N
        DO SROWIDX=1, NA ! LAST PERIOD ASSET
        DO SCOLIDX=1, NZ !LAST PERIOD PRODUCTIVITY
            LAST_AGE = AGEIDX-1
            LAST_CHOICE = PFUNC(SROWIDX, SCOLIDX, LAST_AGE, TIDX-1) ! TWO POSSIBLE
            OLD_POP= STAT_DIST_NEW(SROWIDX,SCOLIDX,LAST_AGE,TIDX-1)/(1.+POP_GROWTH)
            STAT_DIST_NEW(LAST_CHOICE,1,AGEIDX,TIDX) = STAT_DIST_NEW(LAST_CHOICE,1, AGEIDX,TIDX)+OLD_POP*PROD_MARKOV(SCOLIDX,1)
            STAT_DIST_NEW(LAST_CHOICE,2,AGEIDX,TIDX)= STAT_DIST_NEW(LAST_CHOICE,2, AGEIDX,TIDX)+OLD_POP*PROD_MARKOV(SCOLIDX,2)
        ENDDO
        ENDDO
        ENDDO
    ENDDO ! END BIG T LOOP
    DO TIDX=2, T-1
        STAT_DIST(:,:,:,TIDX) = STAT_DIST_NEW(:,:,:,TIDX)
    ENDDO
    PRINT*, COUNT(STAT_DIST/=0), SUM(STAT_DIST(:,:,:,1)), SUM(STAT_DIST(:,:,:,2)), SUM(STAT_DIST(:,:,:,T)), SUM(STAT_DIST)

END SUBROUTINE

SUBROUTINE COMPUTE_ERROR() ! FOR LARGE LOOP
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    REAL(KIND=8), DIMENSION(T-2):: ERR_CAP, ERR_LAB
    INTEGER:: TIDX

    DO TIDX=2,T-1
        CALL EP_PRICE(TIDX,.FALSE.)
    ENDDO
    ERR_CAP = ABS(ACAP_NEW(2:T-1) - AGG_CAP(2:T-1))
    ERR_LAB = ABS(ALAB_NEW(2:T-1) - AGG_LABOR(2:T-1))
    ERROR_MAIN = ABS(MAXVAL((/MAXVAL(ERR_CAP), MAXVAL(ERR_LAB)/)))
    PRINT*, "CAP LAB ERROR:", MAXVAL(ERR_CAP), MAXVAL(ERR_LAB)
    AGG_CAP(2:T-1) = 0.01*ACAP_NEW(2:T-1)+0.99  *AGG_CAP(2:T-1)
    AGG_LABOR(2:T-1) = 0.01*ALAB_NEW(2:T-1) + 0.99*AGG_LABOR(2:T-1)
END SUBROUTINE

SUBROUTINE BACKWARD_INDUCTION(TIDX)
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    INTEGER, INTENT(IN):: TIDX
    INTEGER:: AGEIDX, AGE, SROWIDX, NEXTP, OLDP
    REAL(KIND=8):: CONSUM, UTIL, ERROR_VFI, CRIT_VFI=1e-3

    IF (TIDX/=1 .AND. TIDX/=T) THEN
        NEXTP = TIDX+1
        OLDP = TIDX-1
    ELSE
        NEXTP = TIDX
        OLDP = TIDX
    ENDIF

    ERROR_VFI=100.
    DO WHILE(ERROR_VFI> CRIT_VFI)
        ! FOR LAST AGE, ! SHOULD BE DETERMINISTIC, DO ONCE IS OK (NO CHOICE)
        DO SROWIDX=1,NA ! THIS IS THE CHOICE FROM LAST PERIOD/ CURRENT ASSET
                CONSUM = (1+INTEREST(OLDP))*A_GRID(SROWIDX) + BEN(TIDX) ! SPEND ALL IN LAST PERIOD
                PFUNC(:,:,N, TIDX) = 1 ! ACTUALLY DOES NOT MATTER
                UTIL = CONSUM**((1-SIGMA)*GAMMA)/(1-SIGMA) ! NO NEXT PERIOD VALUE
                VFUNC(SROWIDX,1,N, TIDX) = UTIL
                VFUNC(SROWIDX,2,N, TIDX) = UTIL
                ! ASSET MUST BE ZERO FOR AGE
        ENDDO

        DO AGEIDX = 2, N ! FOR AGE 20-65
            AGE = N- AGEIDX+1
            CALL BELLMAN(AGE, TIDX)
        ENDDO
        ERROR_VFI = MAXVAL(ABS(VFUNC-VFUNC_OLD))
        VFUNC_OLD = VFUNC
    ENDDO
END SUBROUTINE

SUBROUTINE BELLMAN(AGE, TIDX)
    USE OMP_LIB
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    INTEGER, INTENT(IN):: AGE, TIDX
    INTEGER:: NEXTP, OLDP
    REAL(KIND=8):: COND_MAX_UTIL, CONSUM, UTIL, WORKING, PROD, NEXTU
    INTEGER:: SROWIDX, SCOLIDX, CHOICEIDX

    IF (TIDX/=1 .AND. TIDX/=T) THEN
        NEXTP = TIDX+1
        OLDP = TIDX-1
    ELSE
        NEXTP = TIDX
        OLDP = TIDX
    ENDIF
    IF (AGE< RETIRE_AGE) THEN ! WOKRING BELLMAN
        !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(SROWIDX, SCOLIDX, COND_MAX_UTIL, WORKING, PROD, UTIL, NEXTU, CHOICEIDX, CONSUM)
        DO SROWIDX=1, NA
            DO SCOLIDX=1, NZ
                COND_MAX_UTIL = -1e12
                PROD = AGE_EFF(AGE, SCOLIDX)
                DO CHOICEIDX=1,NA ! LOOP OVER CHOICE OF ASSET PRIME
                    CALL FIND_LABOR(CHOICEIDX, SROWIDX, SCOLIDX, AGE, WORKING, TIDX)
                    CONSUM = (1+INTEREST(OLDP))*A_GRID(SROWIDX) + (1-THETA)*PROD*WORKING*WAGE(TIDX) - A_GRID(CHOICEIDX)
                    IF (CONSUM > 0.) THEN
                        NEXTU = BETA*SUM(PROD_MARKOV(SCOLIDX,:)*VFUNC(CHOICEIDX,:,AGE+1, NEXTP))
                        UTIL = (CONSUM**GAMMA*(1-WORKING)**(1-GAMMA))**(1-SIGMA)/(1-SIGMA)+NEXTU
                        IF (UTIL>COND_MAX_UTIL) THEN
                            PFUNC(SROWIDX, SCOLIDX, AGE,TIDX) = CHOICEIDX
                            LFUNC(SROWIDX,SCOLIDX, AGE,TIDX) = WORKING
                            COND_MAX_UTIL = UTIL
                        ENDIF
                    ENDIF
                ENDDO ! END LOOP CHOICE SPACE FOR ONE STATE
                    IF (COND_MAX_UTIL<-1E10) THEN
                    STOP
                    ENDIF
                VFUNC(SROWIDX, SCOLIDX, AGE,TIDX) = COND_MAX_UTIL
            ENDDO
        ENDDO
        !$OMP END PARALLEL DO
    ELSE ! BELLMAN FOR RETIRED PEOPLE
        !$OMP PARALLEL DEFAULT(SHARED) PRIVATE(SROWIDX, SCOLIDX, COND_MAX_UTIL, UTIL, CHOICEIDX, CONSUM )
        !$OMP DO
        DO SROWIDX=1, NA
            COND_MAX_UTIL = -1e12
            DO CHOICEIDX=1, NA
                CONSUM = (1+INTEREST(OLDP))*A_GRID(SROWIDX) + BEN(TIDX) - A_GRID(CHOICEIDX)
                IF (CONSUM>0.) THEN
                    UTIL = CONSUM**((1-SIGMA)*GAMMA)/(1-SIGMA)+ BETA*(VFUNC(CHOICEIDX,1,AGE+1,NEXTP))
                    IF (UTIL>COND_MAX_UTIL) THEN
                        PFUNC(SROWIDX,:, AGE, TIDX) = CHOICEIDX ! NO PRODUCTIVITY DIFFERENCE
                        COND_MAX_UTIL = UTIL
                    ENDIF
                ENDIF
            ENDDO
                IF (COND_MAX_UTIL<-1E10) THEN
                    PRINT*, COND_MAX_UTIL
                    STOP
                ENDIF
            VFUNC(SROWIDX, 1, AGE, TIDX) = COND_MAX_UTIL ! PROD_STATE DO NOT AFFECT RETIRED PEOPLE
            VFUNC(SROWIDX, 2, AGE, TIDX) = COND_MAX_UTIL ! PROD_STATE DO NOT AFFECT RETIRED PEOPLE
        ENDDO
        !$OMP END DO
        !$OMP END PARALLEL
    ENDIF
END SUBROUTINE

SUBROUTINE EP_STAT_DIST(TIDX)
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    INTEGER, INTENT(IN):: TIDX
    INTEGER:: SROWIDX, SCOLIDX, AGEIDX, LAST_AGE, LAST_CHOICE
    REAL(KIND=8), DIMENSION(NA,NZ,N, T):: STAT_DIST_NEW

    ! EVERYONE HAVE ZERO ASSET AT STARTING AGE
    STAT_DIST_NEW = 0.
    STAT_DIST_NEW(1,1,1, TIDX) = 0.2037 ! ALWAYS NO ASSET AT FIRST AGE,
    STAT_DIST_NEW(1,2,1, TIDX) = 0.7963 !  BUT 2 PROD STATES
    DO AGEIDX=2, N
        DO SROWIDX=1, NA ! LAST PERIOD ASSET
            DO SCOLIDX=1, NZ !LAST PERIOD PRODUCTIVITY
                LAST_CHOICE = PFUNC(SROWIDX, SCOLIDX, AGEIDX-1, TIDX) ! TWO POSSIBLE
                LAST_AGE = AGEIDX-1
                STAT_DIST_NEW(LAST_CHOICE, 1, AGEIDX, TIDX) = &
                STAT_DIST_NEW(LAST_CHOICE, 1, AGEIDX, TIDX)+STAT_DIST_NEW(SROWIDX,SCOLIDX,LAST_AGE, TIDX)*PROD_MARKOV(SCOLIDX,1)
                STAT_DIST_NEW(LAST_CHOICE, 2, AGEIDX,TIDX) = &
                STAT_DIST_NEW(LAST_CHOICE, 2, AGEIDX, TIDX) + STAT_DIST_NEW(SROWIDX,SCOLIDX,LAST_AGE, TIDX)*PROD_MARKOV(SCOLIDX,2)
           ENDDO
        ENDDO
    ENDDO
    DO AGEIDX=1,N
        STAT_DIST(:,:,AGEIDX,TIDX) = STAT_DIST_NEW(:,:,AGEIDX,TIDX)*COHORT_POP(AGEIDX)
    ENDDO
END SUBROUTINE

SUBROUTINE EP_PRICE(TIDX, EP)
    ! COMPUTE ERROR AND UPDATE PRICE
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    INTEGER, INTENT(IN):: TIDX
    LOGICAL, INTENT(IN):: EP
    INTEGER:: SROWIDX, SCOLIDX, AGEIDX
    REAL(KIND=8):: EPL_NEW=0., EPK_NEW=0., PORTION, ERROR_EPLAB, ERROR_EPCAP

    EPL_NEW=0.
    EPK_NEW=0.
    DO AGEIDX=1, N ! CAL ERROR
        DO SROWIDX=1,NA
            DO SCOLIDX=1,NZ
                PORTION = STAT_DIST(SROWIDX, SCOLIDX, AGEIDX,TIDX)
                    EPK_NEW = EPK_NEW+ A_GRID(SROWIDX)*PORTION
                IF (AGEIDX<RETIRE_AGE) THEN
                    EPL_NEW = EPL_NEW+LFUNC(SROWIDX,SCOLIDX,AGEIDX, TIDX)*PORTION*AGE_EFF(AGEIDX,SCOLIDX)
                ENDIF
            ENDDO
        ENDDO
    ENDDO

    IF (EP) THEN
        ERROR_EPLAB = ABS(EPL_NEW-AGG_LABOR(TIDX))
        ERROR_EPCAP = ABS(EPK_NEW-AGG_CAP(TIDX))
        PRINT*, "UPDATE_PRICE ERROR", ERROR_EPLAB, ERROR_EPCAP
        ERROR_EP = MAX(ERROR_EPLAB, ERROR_EPCAP)
        AGG_LABOR(TIDX) = 0.05*EPL_NEW + 0.95*AGG_LABOR(TIDX)
        AGG_CAP(TIDX) = 0.05*EPK_NEW + 0.95*AGG_CAP(TIDX)
    ELSE
        ACAP_NEW(TIDX)= EPK_NEW
        ALAB_NEW(TIDX)= EPL_NEW
    ENDIF
END SUBROUTINE

SUBROUTINE FIND_LABOR(CHOICEIDX, SROWIDX, SCOLIDX, AGE, WORKING, TIDX)
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    INTEGER, INTENT(IN):: CHOICEIDX, SROWIDX, SCOLIDX, AGE, TIDX
    INTEGER:: NEXTP, OLDP
    REAL(KIND=8), INTENT(OUT):: WORKING
    REAL(KIND=8):: LAST_CHOICE, CUR_CHOICE, OPT_LABOR, NOM

    IF (TIDX<CHANGE) THEN
        THETA = THE_OLD
    ELSE
        THETA = THE_NEW
    ENDIF

    IF (TIDX/=1 .AND. TIDX/=T) THEN
        NEXTP = TIDX+1
        OLDP = TIDX-1
    ELSE
        NEXTP = TIDX
        OLDP = TIDX
    ENDIF

    CUR_CHOICE = A_GRID(CHOICEIDX)
    IF (AGE/=1) THEN
        LAST_CHOICE = (1+INTEREST(OLDP))*A_GRID(SROWIDX) ! DISCOUNTED
    ELSE
        LAST_CHOICE = 0.
    ENDIF
    NOM = (GAMMA*(1-THETA)*AGE_EFF(AGE,SCOLIDX)*WAGE(TIDX)-(1-GAMMA)*(LAST_CHOICE-CUR_CHOICE))
    OPT_LABOR = NOM/((1-THETA)*WAGE(TIDX)*AGE_EFF(AGE,SCOLIDX))
    IF (OPT_LABOR > 1.0) THEN
        OPT_LABOR = 1.0
    ELSE IF (OPT_LABOR < 0.) THEN
        OPT_LABOR = 0.0
    ENDIF
    WORKING = OPT_LABOR
END SUBROUTINE

SUBROUTINE CAL_POINT_MOM(TIDX)
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    INTEGER, INTENT(IN):: TIDX

    IF (TIDX<CHANGE) THEN
        THETA = THE_OLD
    ELSE
        THETA = THE_NEW
    ENDIF

    WAGE(TIDX) = (1-ALPHA)*(AGG_CAP(TIDX)**(ALPHA))*(AGG_LABOR(TIDX)**(-ALPHA))! FOC WRT LABOR
    INTEREST(TIDX) = ALPHA*(AGG_CAP(TIDX)**(ALPHA-1))*(AGG_LABOR(TIDX)**(1-ALPHA))-DELTA! FOC WRT CAPITAL
    BEN(TIDX) = THETA*WAGE(TIDX)*AGG_LABOR(TIDX)/SUM(COHORT_POP(RETIRE_AGE:N)) ! TAX REV

END SUBROUTINE

SUBROUTINE WRITE_ALL()
    USE PS6RES
    USE PS6PARA
    IMPLICIT NONE
    INTEGER:: SROWIDX
    CHARACTER(LEN=130):: PATH="/Users/chek_choi/Downloads/fortran/"
    CHARACTER(LEN=150):: FILE_NAME

        FILE_NAME = TRIM(PATH)//"VFUNC"
        OPEN(UNIT=1, FILE=FILE_NAME, STATUS='REPLACE') ! START WITH THE TWO VALUE FUNCTIONS
        DO SROWIDX=1, NA
            WRITE(UNIT=1,FMT=*) VFUNC(SROWIDX,:, 50,1)
        ENDDO
        CLOSE(UNIT=1)

        FILE_NAME = TRIM(PATH)//"PFUNC"
        OPEN(UNIT=2, FILE=FILE_NAME, STATUS='REPLACE') ! ALSO SAVE POLICY FUNCTIONS
        DO SROWIDX=1, NA
            WRITE(UNIT=2,FMT=*) A_GRID(PFUNC(SROWIDX,1, 20,1)), A_GRID(PFUNC(SROWIDX,2, 20,1))
        ENDDO
        CLOSE(UNIT=2)

        FILE_NAME = TRIM(PATH)//"STATDIST"
        OPEN(UNIT=3, FILE=FILE_NAME, STATUS='REPLACE') ! ALSO SAVE POLICY FUNCTIONS
        DO SROWIDX=1, NA
            WRITE(UNIT=3,FMT=*) STAT_DIST(SROWIDX, :, 50,1)
        ENDDO
        CLOSE(UNIT=3)

        FILE_NAME = TRIM(PATH)//"CAPPATH"
        OPEN(UNIT=4, FILE=FILE_NAME, STATUS='REPLACE') ! FOR HAVING THE X-AXIS OF PLOT
        DO SROWIDX=1, T
            WRITE(UNIT=4,FMT=*) AGG_CAP(SROWIDX)
        ENDDO
        CLOSE(UNIT=4)

        FILE_NAME = TRIM(PATH)//"AGRID"
        OPEN(UNIT=5, FILE=FILE_NAME, STATUS='REPLACE') ! START WITH THE TWO VALUE FUNCTIONS
        DO SROWIDX=1, NA
            WRITE(UNIT=5,FMT=*) A_GRID(SROWIDX)
        ENDDO
        CLOSE(UNIT=5)

        FILE_NAME = TRIM(PATH)//"LABPATH"
        OPEN(UNIT=32, FILE=FILE_NAME, STATUS='REPLACE') ! START WITH THE TWO VALUE FUNCTIONS
        DO SROWIDX=1, T
            WRITE(UNIT=32,FMT=*) AGG_LABOR(SROWIDX)
        ENDDO
        CLOSE(UNIT=32)

        FILE_NAME = TRIM(PATH)//"RPATH"
        OPEN(UNIT=33, FILE=FILE_NAME, STATUS='REPLACE') ! START WITH THE TWO VALUE FUNCTIONS
        DO SROWIDX=1, T
            WRITE(UNIT=33,FMT=*) INTEREST(SROWIDX)
        ENDDO
        CLOSE(UNIT=33)

        FILE_NAME = TRIM(PATH)//"WPATH"
        OPEN(UNIT=34, FILE=FILE_NAME, STATUS='REPLACE') ! START WITH THE TWO VALUE FUNCTIONS
        DO SROWIDX=1, T
            WRITE(UNIT=34,FMT=*) WAGE(SROWIDX)
        ENDDO
        CLOSE(UNIT=34)

END SUBROUTINE

SUBROUTINE CONSUM_EQ()
    USE PS6RES
    USE PS6PARA
    IMPLICIT NONE
    INTEGER:: RIDX, CIDX, IDX
    REAL(KIND=8), DIMENSION(NA,NZ,N):: VFUNC_BEN
    REAL(KIND=8), DIMENSION(NA,NZ,N,2):: VFUNC_NOBEN=0.
    REAL(KIND=8), DIMENSION(N,2):: CONS_EQ

    VFUNC_BEN = VFUNC(:,:,:,1)
    VFUNC_NOBEN(:,:,:,1) = VFUNC(:,:,:,2)
    VFUNC_NOBEN(:,:,:,2) = VFUNC(:,:,:,2)
    !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(RIDX)
    DO RIDX=1, N
        CONS_EQ(RIDX,1) = SUM(VFUNC_NOBEN(:,:,RIDX,1))-SUM(VFUNC_BEN(:,:,RIDX))
        CONS_EQ(RIDX,2) = SUM(VFUNC_NOBEN(:,:,RIDX,2))-SUM(VFUNC_BEN(:,:,RIDX))
    ENDDO
    !$OMP END PARALLEL DO

    OPEN(UNIT=28, FILE='CONSUM_EQ', STATUS='REPLACE')
        DO RIDX=1,N
            WRITE(UNIT=28, FMT=*) CONS_EQ(RIDX, :)
        ENDDO
    CLOSE(UNIT=28)
    PRINT*, "========================================"
END SUBROUTINE




