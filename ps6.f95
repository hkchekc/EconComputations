MODULE PS6PARA
    IMPLICIT NONE
    INTEGER, PARAMETER:: N=66, RETIRE_AGE=46, T=30, SHIFT_PERIOD=2
    REAL(KIND=8), PARAMETER:: A_MAX=2.0, A_MIN=-0.525, STEP=0.005
    INTEGER, PARAMETER:: NZ=2, NA=(A_MAX-A_MIN)/STEP
    REAL(KIND=8):: ALPHA=0.5, BETA=0.8
    REAL(KIND=8):: THETA_OLD=0.11, THETA_NEW=0, GAMMA=0.42, SIGMA=2.0, DELTA=0.06, POP_GROWTH= 0.011
    REAL(KIND=8), DIMENSION(2):: PROD_STATES = (/3.0, 0.5/)
    REAL(KIND=8), DIMENSION(2,2):: PROD_MARKOV = TRANSPOSE(RESHAPE((/0.9261,(1-0.9261),(1-0.9811),0.9811/),(/NZ,NZ/)))
    REAL(KIND=8), DIMENSION(N):: COHORT_POP
    REAL(KIND=8), DIMENSION(NA):: A_GRID
    REAL(KIND=8), DIMENSION(N,NZ):: AGE_EFF
    CONTAINS
        SUBROUTINE INIT_ARRAY()
                INTEGER:: I, SROWIDX
                COHORT_POP= (/((1.0/((1.0+POP_GROWTH)**I)), I=1,N)/)
                COHORT_POP(:) = COHORT_POP(:)/SUM(COHORT_POP) ! NORMALIZE TO 1
                A_GRID = (/(I*STEP, I=1,NA)/) + A_MIN - STEP
                AGE_EFF(:,:)=0.
                OPEN(UNIT=13, FILE='ef.txt', STATUS='OLD')
                DO SROWIDX=1,RETIRE_AGE-1
                    READ(UNIT=13, FMT=*) AGE_EFF(SROWIDX,1)
                ENDDO
                CLOSE(UNIT=13)
                AGE_EFF(:,1) = AGE_EFF(:,1)*0.5
                AGE_EFF(:,2) = AGE_EFF(:,1)*3.0
        END SUBROUTINE INIT_ARRAY
END MODULE

MODULE PS6RES
    USE PS6PARA
    IMPLICIT NONE
    REAL(KIND=8), DIMENSION(T):: BENEFIT, INTEREST, WAGE, AGG_LABOR, AGG_CAP, THETA_PATH, ERRORS
    REAL(KIND=8), DIMENSION(NA,NZ,N, T):: VFUNC, LFUNC, STAT_DIST, VFUNC_NEW
    INTEGER, DIMENSION(NA,NZ,N, T):: PFUNC=0
    CONTAINS
    SUBROUTINE INIT_RESARRAY()
            AGG_LABOR(:) = 1.0
            AGG_CAP(:) = 1.0
            THETA_PATH(1:SHIFT_PERIOD) = THETA_OLD
            THETA_PATH(SHIFT_PERIOD:T) = THETA_NEW
    END SUBROUTINE INIT_RESARRAY
END MODULE

PROGRAM PS6
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    REAL(KIND=8):: ERROR=100., CRIT=1e-2
    INTEGER:: TIMEIDX, PERIOD

    CALL INIT_ARRAY()
    CALL INIT_RESARRAY()
    CALL FIND_END_POINT() ! FIND THE END POINT, OUTSIDE OF LOOP BECAUSE THETA FIXED AT THESE POINTS
    PRINT*, "ABC"

    ! START MAIN LOOP
    DO WHILE (ERROR>CRIT)

        DO TIMEIDX=2, T-1
            PERIOD = T-TIMEIDX
            CALL FIND_POINTS(PERIOD)
        ENDDO
        CALL FIND_STAT_DIST()
        ! COMPUTE ERROR UPDATE PRICE
        CALL COMPUTE_ERROR(ERROR)
        CALL UPDATE_PRICE()
        PRINT*, "ERROR:", ERROR
        PRINT*, "R, B,W:", INTEREST, BENEFIT, WAGE
        PRINT*, "=================================================="
    ENDDO

END PROGRAM PS6

! SUBROUTINES
SUBROUTINE FIND_END_POINT()
    ! FROM THETA = 0.11 TO THETA = 0
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    REAL(KIND=8):: ERROR_END=100., CRIT_END=1e-2

    DO WHILE (ERROR_END> CRIT_END)
        ! CALCULATE START POINT WITH THETA=0.11
        PRINT*, "PRE"
        CALL FIND_POINTS(1)
        ! CALCULATE END POINT WITH THEA= 0 SS
                PRINT*, "MID"
        CALL FIND_POINTS(T)
        ! FIND STAT_DIST (DONT NEED NEW SUBROUTINE)
        ! CAL ERROR
        ERROR_END = 0.
        ! FIND SS PRICE
    ENDDO
END SUBROUTINE

SUBROUTINE FIND_POINTS(PERIOD) ! SAME AS PS5
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    INTEGER, INTENT(IN):: PERIOD
    REAL(KIND=8):: OPT_LABOR, NOM, THETA_T, THIS_EFF
    REAL(KIND=8):: ERROR=100. , CRIT_P=1e-3, LAST_CHOICE, CUR_CHOICE
    INTEGER:: AGEIDX, SROWIDX, SCOLIDX

    IF (PERIOD==1) THEN
        THETA_T = THETA_OLD
    ELSE IF (PERIOD==T) THEN
        THETA_T = THETA_NEW
    ELSE
        THETA_T = THETA_PATH(PERIOD)
    ENDIF

    DO WHILE(ERROR>CRIT_P)
        ! UPDATE VARS

        ! FIND OPTIMAL LABOR AND POPULATE LFUNC
        DO AGEIDX=1, RETIRE_AGE
            DO SROWIDX=1,NA
                DO SCOLIDX=1,NZ
                    CUR_CHOICE = A_GRID(PFUNC(SROWIDX,SCOLIDX,AGEIDX, PERIOD))
                    IF (AGEIDX/=1) THEN
                        LAST_CHOICE = (1+INTEREST(PERIOD))*A_GRID(PFUNC(SROWIDX,SCOLIDX,AGEIDX-1, PERIOD-1)) ! DISCOUNTED
                    ELSE
                        LAST_CHOICE = 0.
                    ENDIF
                    THIS_EFF =AGE_EFF(AGEIDX,SCOLIDX)*WAGE(PERIOD)
                    NOM = (GAMMA*(1-THETA_T)*PROD_STATES(SCOLIDX)*THIS_EFF-(1-GAMMA)*(LAST_CHOICE-CUR_CHOICE))
                    OPT_LABOR = NOM/((1-THETA_T)*WAGE(PERIOD)*PROD_STATES(SCOLIDX)*AGE_EFF(AGEIDX,SCOLIDX))
                    IF (OPT_LABOR > 1.0) THEN
                        OPT_LABOR = 1.0
                    ELSE IF (OPT_LABOR < 0.) THEN
                        OPT_LABOR = 0.0
                    ENDIF
                LFUNC(SROWIDX, SCOLIDX, AGEIDX, PERIOD) = OPT_LABOR
                ENDDO
            ENDDO
        ENDDO
        ! BACKWARD INDUCTION USING NEW VARS (BELLMAN)
        CALL BACKWARD_INDUCTION(PERIOD)
    ENDDO

END SUBROUTINE

SUBROUTINE BACKWARD_INDUCTION(PERIOD)
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    INTEGER, INTENT(IN):: PERIOD
    INTEGER:: AGEIDX, AGE, SROWIDX
    REAL(KIND=8):: CONSUM, UTIL, ERROR_VFI=100.

    ! FOR LAST AGE, ! SHOULD BE DETERMINISTIC, DO ONCE IS OK (NO CHOICE)
    DO SROWIDX=1,NA ! THIS IS THE CHOICE FROM LAST PERIOD/ CURRENT ASSET
            CONSUM = (1+INTEREST(PERIOD))*A_GRID(SROWIDX) + BENEFIT(PERIOD) ! SPEND ALL IN LAST PERIOD
            PFUNC(:,:,N, PERIOD) = 1 ! ACTUALLY DOES NOT MATTER
            UTIL = CONSUM**((1-SIGMA)*GAMMA)/(1-SIGMA) ! NO NEXT PERIOD VALUE
            VFUNC_NEW(SROWIDX,:,N,PERIOD) = UTIL
    ENDDO

    DO AGEIDX = 2, N ! FOR AGE 20-65
        AGE = N- AGEIDX+1
        CALL BELLMAN(PERIOD, AGE)
    ENDDO
    ERROR_VFI = MAXVAL(ABS(VFUNC_NEW-VFUNC)) ! OTHER PERIOD VFI SHOULD BE UNCHANGED, SO IS OK
    VFUNC = VFUNC_NEW
END SUBROUTINE

SUBROUTINE BELLMAN(PERIOD, AGE)
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    INTEGER, INTENT(IN):: PERIOD, AGE
    REAL(KIND=8):: COND_MAX_UTIL, CONSUM, UTIL, WORKING, PROD, NEXTU
    INTEGER:: SROWIDX, SCOLIDX, CHOICEIDX

    IF (AGE< RETIRE_AGE) THEN ! WOKRING BELLMAN
        DO SROWIDX=1, NA
            DO SCOLIDX=1, NZ
                COND_MAX_UTIL = -1e12
                WORKING = LFUNC(SROWIDX, SCOLIDX, AGE, PERIOD)
                PROD = PROD_STATES(SCOLIDX)
                DO CHOICEIDX=1,NA ! LOOP OVER CHOICE OF ASSET PRIME
                    CONSUM = A_GRID(SROWIDX) + PROD*WORKING - INTEREST(PERIOD)* A_GRID(CHOICEIDX)
                    IF (CONSUM > 0.) THEN
                        NEXTU = BETA*SUM(PROD_MARKOV(SCOLIDX,:)*VFUNC(CHOICEIDX,:,AGE+1, PERIOD))
                        UTIL = (CONSUM**GAMMA*(1-WORKING)**(1-GAMMA))**(1-SIGMA)/(1-SIGMA)+NEXTU
                        IF (UTIL>COND_MAX_UTIL) THEN
                            PFUNC(SROWIDX, SCOLIDX, AGE, PERIOD) = CHOICEIDX
                            COND_MAX_UTIL = UTIL
                        ENDIF
                    ENDIF
                ENDDO ! END LOOP CHOICE SPACE FOR ONE STATE
            ENDDO
        ENDDO
        VFUNC_NEW(SROWIDX, SCOLIDX, AGE, PERIOD) = COND_MAX_UTIL
    ELSE ! BELLMAN FOR RETIRED PEOPLE
        DO SROWIDX=1, NA
            COND_MAX_UTIL = -1e12
            DO CHOICEIDX=1, NA
                CONSUM = A_GRID(SROWIDX) + BENEFIT(PERIOD)
                IF (CONSUM>0.) THEN
                    UTIL = CONSUM**((1-SIGMA)*GAMMA)/(1-SIGMA)+ BETA*(VFUNC(CHOICEIDX,1,AGE+1,PERIOD+1))
                    IF (UTIL>COND_MAX_UTIL) THEN
                        PFUNC(SROWIDX,:, AGE, PERIOD) = CHOICEIDX
                        COND_MAX_UTIL = UTIL
                    ENDIF
                ENDIF
            ENDDO
        ENDDO
        VFUNC_NEW(SROWIDX, :, AGE, PERIOD) = COND_MAX_UTIL ! PROD_STATE DO NOT AFFECT RETIRED PEOPLE
    ENDIF
END SUBROUTINE

SUBROUTINE FIND_STAT_DIST()
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    INTEGER:: SROWIDX, SCOLIDX, AGEIDX, LAST_AGE, LAST_CHOICE, TIDX, I
    REAL(KIND=8), DIMENSION(NA,NZ,N,T):: STAT_DIST_NEW
    REAL(KIND=8):: ERROR_STAT=100., CRIT_STAT=1e-2, OLD_POP


    STAT_DIST(:,:,:,:) = 1.0/SIZE(STAT_DIST)*T ! START WITH UNIFORM
    ! EVERYONE HAVE ZERO ASSET AT STARTING AGE
    DO WHILE (ERROR_STAT>CRIT_STAT)
        STAT_DIST_NEW(:,:,:,:) = 0.
        STAT_DIST_NEW(:,1,1,:) = 0.2037* COHORT_POP(1)/SIZE(A_GRID) ! ALWAYS NO ASSET AT FIRST AGE, BUT 2 PROD STATES
        STAT_DIST_NEW(:,2,1,:) = 0.7963*COHORT_POP(1)/SIZE(A_GRID)
        DO TIDX=2,T ! WHAT IS THE DISTRIBUTION OF TIME
            DO AGEIDX=2, N
                DO SROWIDX=1, NA ! LAST PERIOD ASSET
                    DO SCOLIDX=1, NZ !LAST PERIOD PRODUCTIVITY
                        LAST_AGE = AGEIDX-1
                        LAST_CHOICE = PFUNC(SROWIDX, SCOLIDX, LAST_AGE, TIDX-1) ! TWO POSSIBLE
                        DO I=1,2
                            OLD_POP= STAT_DIST_NEW(SROWIDX,I,LAST_AGE,TIDX-1)
                            STAT_DIST_NEW(LAST_CHOICE, 1, AGEIDX, TIDX) = OLD_POP*PROD_MARKOV(1,SCOLIDX)
                            STAT_DIST_NEW(LAST_CHOICE, 2, AGEIDX,TIDX) =  OLD_POP*PROD_MARKOV(2,SCOLIDX)
                        ENDDO
                   ENDDO
                ENDDO
                STAT_DIST_NEW(:,:,AGEIDX,TIDX) = STAT_DIST_NEW(:,:,AGEIDX,TIDX)*COHORT_POP(AGEIDX)
            ENDDO
        ENDDO
        ERROR_STAT = ABS(MAXVAL(STAT_DIST_NEW-STAT_DIST))
        STAT_DIST = STAT_DIST_NEW
    ENDDO
END SUBROUTINE

SUBROUTINE UPDATE_PRICE() ! FOR INTERIOR
    ! COMPUTE ERROR AND UPDATE PRICE
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    INTEGER:: SROWIDX, SCOLIDX, AGEIDX, TIDX
    REAL(KIND=8):: AGG_LABOR_NEW=0, AGG_CAP_NEW=0, PORTION

    WAGE = (1-ALPHA)*(AGG_CAP**ALPHA)*(AGG_LABOR**(-ALPHA))! FOC WRT LABOR
    INTEREST = ALPHA*(AGG_CAP**(ALPHA-1))*(AGG_LABOR**(1-ALPHA))-DELTA! FOC WRT CAPITAL
    BENEFIT = THETA_PATH*WAGE*AGG_LABOR/SUM(COHORT_POP(RETIRE_AGE:N)) ! TAX REV/RETIRED_POP
    ! UPDATE INTEREST, WAGE, BENEFIT AT THE START OF NEXT PERIOD (IT IS THE SAME)
END SUBROUTINE

SUBROUTINE COMPUTE_ERROR(ERROR) ! GROUP UP THE AGG_LABOR CAAP AND CALCUALTE THE ERROR FOR WHOLE PATH
    USE PS6PARA
    USE PS6RES
    IMPLICIT NONE
    REAL(KIND=8), INTENT(OUT):: ERROR
    INTEGER:: SROWIDX, SCOLIDX, AGEIDX, TIDX
    REAL(KIND=8), DIMENSION(T):: AGG_CAP_NEW, AGG_LAB_NEW
    REAL(KIND=8):: ERROR_LAB, ERROR_CAP, PORTION

    ! DO SOMETHING TO NORMALIZE THE STAT DISTRIBUTION
    DO TIDX=1, T
        DO AGEIDX=1, N ! CAL ERRORS
            DO SROWIDX=1,NA
                DO SCOLIDX=1,NZ
                    PORTION = STAT_DIST(SROWIDX, SCOLIDX, AGEIDX, TIDX)
                    AGG_CAP_NEW = AGG_CAP_NEW+ A_GRID(SROWIDX)*PORTION
                    IF (AGEIDX<RETIRE_AGE) THEN
                        AGG_LAB_NEW = AGG_LAB_NEW + LFUNC(SROWIDX, SCOLIDX, AGEIDX, TIDX)*PORTION*AGE_EFF(AGEIDX, SCOLIDX)
                    ENDIF
                ENDDO
            ENDDO
        ENDDO
    ENDDO

    ! IN THE END, UPDATE LABOR AND CAP
    ERROR_LAB = MAXVAL(ABS(AGG_LAB_NEW-AGG_LABOR))
    ERROR_CAP = MAXVAL(ABS(AGG_CAP_NEW-AGG_CAP))
    PRINT*, "UPDATE_PRICE ERROR", ERROR_LAB, ERROR_CAP
    ERROR = MAX(ERROR_CAP, ERROR_LAB)
    AGG_LABOR = 0.05*AGG_LAB_NEW + 0.95*AGG_LABOR
    AGG_CAP = 0.05*AGG_CAP_NEW + 0.95*AGG_CAP
END SUBROUTINE




